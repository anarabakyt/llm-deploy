Описание проекта на словах пользователя:
Проект представляет собой агрегатор всех AI-агентов моделей LLM. Например, у нас есть Cloud, или ChatGPT, или DeepSeek, и пользователь может в этом приложении переписываться с каждой моделью. Как я это вижу? Я вижу это как веб-приложение, построенное на Byte и React, с использованием Tailwind, с использованием Redux. Представляет оно из себя вкладку в браузере, то есть это веб-приложение. Слева у нас разделительная черта, как в ChatGPT с чатами. По центру у нас переписка будет отображаться с пользователем, и снизу переписки поле ввода. Итак, слева, где сайт-бар для чатов, будет располагаться первый фиксированный чат, который будет назваться протестить ИИ, или протестировать ИИ. Если на него нажать, то открывается чат, как обычно, туда в поле ввода вписывает пользователь какой-то свой запрос, он улетает, и в N8n идет запрос сразу в несколько LLM-моделей. Потом все это агрегируется, и в чат, в котором писал пользователь, возвращается несколько ответов столбцом с каждой LLM-модели. Каждый столбец представляет собой, точнее один элемент в столбце представляет собой краткое название модели и превью текста, который ответил теломодель. И таких элементов в столбце несколько. Если нажать на превью, то показывается полный ответ от модели, и можно обратно свернуть, таким образом человек может посмотреть, что ответила та или иная модель, и лайкнуть или дизлайкнуть. Также будет отображаться время отклика, то есть какая модель быстрее справилась с ответом. Далее, помимо фиксированного чата, слева будут по отдельности модели. Например, модель чат GPT. Если ее выделить и нажать, то будет открываться новый чат. Также она этой моделью в той же боковой панели под этой моделью будет разворачивать список чатов, как в чат GPT, в которых переписывался пользователь. Если нажать обратно на модель, то список сворачивается. И таких моделей много. Например, нажал на клоуд, развернулся список чата, в котором можно создавать новый чат, переписываться в старом чате.
Перед тем, как пользователь заходит, прежде чем отправить сообщение, ему предлагается регистрироваться. Регистрация пока что только через Google Auth. Получается, что я хочу сделать? Я хочу сделать базу данных, в которых будет таблица пользователей, потом будет таблица моделей, потом будет таблица чатов, и потом будет таблица переписки. Получается, как я это вижу, пользователь зарегистрировался, мы аутентифицируемся в Google на приложении, отправляем запрос в N8N узел. Этот узел по аутентификации возвращает необходимый User ID, и потом пользователь по этому User ID уже пользуется. Либо Java Web Token в зависимости, что там в Google аутентификации. Далее. Как я хочу реализовать чаты? Я хочу, чтобы компонент именно чата был как контейнер. В контейнер я помещаю все месседжи. Один месседж – это отправка пользователя, либо ответ от модели. И получается, если я как пользователь написал сообщение, то у меня сформировался один чат-месседж, и я его отправляю в определенный чат. И это нужно сделать асинхронным. Как это сделать, ты мне, пожалуйста, помоги. Получается, я хочу использовать Redux, когда я использую главный компонент, я переключаюсь на зону чата, назовем ее chat-area. Я передаю в Props туда конкретный чат, текущий, например, модель, или фиксированный чат, или, например, клоудж, чат GPT там. Потом я передаю туда список месседжей. Если чат новый, то месседжи пустой. И chat-area должен отображать список месседжей. Получается, если я создал новый чат, я должен просто создать тип для месседжа, положить его в список, и тогда зона чата должна его отобразить. Но дело в том, что чаты должны быть еще асинхронными. Например, если я написал в одном чате, переключусь на другой, то переписка уже заменилась на другой чат. Получается, у нас должно быть состояние для каждого чата.

Структура приложения по словам пользователя:
Идея приложения
---------------
Агрегатор всех AI-агентов (LLM-моделей): Claude, ChatGPT, DeepSeek.
Пользователь может переписываться с каждой моделью в одном веб-приложении.

Технологический стек
--------------------
Frontend: React + Vite
UI: TailwindCSS
State management: Redux
Интеграция с backend: через n8n

Интерфейс
---------
Сайдбар (слева):
- Разделительная черта, как в ChatGPT
- Фиксированный чат: "Протестировать ИИ"
  - При выборе:
    - Ввод запроса → запрос уходит в n8n → рассылается в несколько LLM
    - Ответ агрегируется и возвращается в чат

Центр (основная область):
- Отображается переписка
- Снизу — поле ввода сообщения

Особенности "Протестировать ИИ"
-------------------------------
Ответ приходит в виде карточек:
- Название модели
- Превью текста ответа
- При клике — полный ответ (можно свернуть)
- Лайк/дизлайк ответа
- Время отклика модели

Отдельные модели (в сайдбаре)
-----------------------------
- Например: "ChatGPT", "Claude"
- При нажатии:
  - Разворачивается список чатов с этой моделью
  - Можно выбрать старый чат или создать новый
  - Повторное нажатие — сворачивает список

Аутентификация и пользователи
-----------------------------
Регистрация: через Google Auth

База данных (минимум таблиц):
- users — данные о пользователях
- models — список доступных LLM-моделей
- chats — чаты пользователей и моделей
- messages — сообщения в рамках чата

Механизм:
- Пользователь логинится через Google
- Приложение → запрос в n8n → узел аутентификации
- Узел возвращает User ID или JWT
- User ID используется для привязки чатов и сообщений

Архитектура чатов
-----------------
Компонент ChatArea:
- Вход: текущий чат (id + модель или "протестировать ИИ"), список сообщений
- Отображает список сообщений
- Снизу — поле ввода нового сообщения

Сообщение (Message):
- Тип: user | model
- Свойства: id, chatId, author, text (preview/full), createdAt, status (отправляется | получено | ошибка)

Добавление сообщений:
1. Создаётся объект message
2. Сохраняется в Redux (UI сразу показывает)
3. Асинхронно отправляется в backend (n8n)
4. После ответа модели → обновление Redux (новое сообщение или обновление существующего)

Асинхронность и переключение чатов
----------------------------------
Redux state (пример):
{
  user: { id, email, ... },
  chats: {
    byId: {
      chatId1: { id: 'chatId1', model: 'gpt', messages: [...] },
      chatId2: { id: 'chatId2', model: 'claude', messages: [...] }
    },
    allIds: ['chatId1', 'chatId2'],
    selectedChatId: 'chatId1'
  }
}

Логика:
- Переключение чата → меняется selectedChatId
- ChatArea отображает сообщения только выбранного чата
- Новый чат → пустой список, пока нет сообщений
- Асинхронные вызовы моделей (через n8n) независимы, ответы приходят в соответствующий чат
